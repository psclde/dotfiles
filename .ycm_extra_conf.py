# This ycm_extra_conf.py tries to be as generic as possible.
#
# Should work for C (.c, .h) and C++ (.cpp, .hpp) files.
#
# First it searches in the source tree for the compile_commands.json
# generated by CMake. It assumes that a directory named 'build' is somewhere
# in the source tree (basically the CMake building directory)
# Because the compile_commands.json file does not contain any information
# about the header files the script tries to find the corresponding source file
# or, if that fails, any other source file in the same directory and uses the
# flags of that file.
#
# If no compile_commands.json file is found some default flags will be returned.
#
# It most definitly has bugs and edge cases and will be improved in the future.

import ycm_core
import os

DEFAULT_FLAGS = [
'-Wall',
'-Wextra',
'-Weverything',
'-pedantic',
'-DNDEBUG',
'-isystem',
'/usr/local/include',
'-isystem',
'/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1',
'-isystem',
'/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include',
'-isystem',
'/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/',
]
# TODO parse includes files from 'echo | clang -v -E -x [c++|c] -'

SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]
DATABASE = None # the ycm_core database

def isHeaderFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.hpp']

def isCFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.c']

def isCPPFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.hpp', '.cpp']

def discoverCompileCommandJSON(filename, cmake_dir):
    """
    Searches for the compile_commands.json generated by CMake and returns
    its directory as needed by ycm. It will only search a maximum of 5
    directories (including the direcotry of filename).
    filename is the path of a source file (.c, .h, ...).
    cmake_dir is the name of build directory to search for.
    """
    dirname = filename
    for i in range(0, 5):
        dirname, fn = os.path.split(dirname)
        comp_commands = os.path.join(dirname, cmake_dir, 'compile_commands.json')
        if os.path.exists(comp_commands):
            return os.path.join(dirname, cmake_dir)
        if not fn: # reached root dir
            return

def getFlagsForHeaderFile(header_file, database):
    """
    Tries to find the compile flags for the header file.
    First searches for the corresponding source file (foo.h -> foo.c,
    foo.hpp -> foo.cpp). If this fails searches for any source file in the same
    directory and uses its flags.
    """
    source_ext = '.c' if isCFile(header_file) else '.cpp'
    source_file = os.path.join(os.path.splitext(header_file)[1], source_ext)
    if os.path.exists(source_file):
        comp_info = database.GetCompilationInfoForFile(source_file)
        return list(comp_info.compiler_flags_)
    else:
        directory = os.path.split(header_file)[0]
        for f in os.listdir(directory):
            if f.endswith(source_ext):
                path = os.path.join(directory, f)
                comp_info = database.GetCompilationInfoForFile(path)
                return list(comp_info.compiler_flags_)
    return None


def FlagsForFile(filename, **kwargs):
    flags = []
    comp_commands = discoverCompileCommandJSON(filename, 'build')
    if comp_commands:
        if not DATABASE:
            global DATABASE
            DATABASE = ycm_core.CompilationDatabase(comp_commands)

        if not DATABASE.DatabaseSuccessfullyLoaded:
            raise Exception("cmake database failed to load")

        if isHeaderFile(filename):
            flags += getFlagsForHeaderFile(filename, DATABASE)
        else:
            comp_info = DATABASE.GetCompilationInfoForFile(filename)
            flags += list(comp_info.compiler_flags_)
    else:
        flags += DEFAULT_FLAGS
        if isCFile(filename):
            flags += ['-std=c99', '-x', 'c']
        elif isCPPFile(filename):
            flags += ['-std=c++11', '-x', 'c++']

    extra_flags = ['-Wno-newline-eof', '-Wno-padded', '-Wno-cast-align']
    final_flags = flags + extra_flags
    return { 'flags': final_flags, 'do_cache': True }

