# This ycm_extra_conf.py tries to be as generic as possible.
#
# Should work for C (.c, .h) and C++ (.cpp, .hpp) files.
#
# First it searches in the source tree for the compile_commands.json
# generated by CMake. It assumes that a directory named 'build' is somewhere
# in the source tree (basically the CMake building directory)
# Because the compile_commands.json file does not contain any information
# about the header files the script tries to find the corresponding source file
# or, if that fails, any other source file in the same directory and uses the
# flags of that file.
#
# If no compile_commands.json file is found some default flags will be returned.
#
# It most definitly has bugs and edge cases and will be improved in the future.

import ycm_core
import os
from subprocess import Popen, PIPE

def getClangIncludePaths(lang):
    """
    Gets the default include paths from clang for the specified language.
    """
    p = Popen(["clang", "-v", "-E", "-x", lang, "-"], stdin=PIPE, stdout=PIPE,
            stderr=PIPE)
    output = p.communicate("\n")[1]

    flags = []
    foundFlags = False
    for line in output.splitlines():
        if line == "#include <...> search starts here:":
            foundFlags = True
            continue
        if line == "End of search list.":
            break

        if foundFlags and "(framework directory)" not in line:
            flags.append('-isystem')
            flags.append(line.strip())
    return flags


DEFAULT_FLAGS = [
'-Wall',
'-Wextra',
'-Weverything',
'-Wno-newline-eof',
'-pedantic',
'-DNDEBUG',
'-isystem',
'/usr/local/include',
]

C_INCLUDES = getClangIncludePaths('c')
CPP_INCLUDES = getClangIncludePaths('c++')

DATABASE = None # the ycm_core database

def isHeaderFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.hpp']

def isCFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.c']

def isCPPFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.hpp', '.cpp']

def discoverCompileCommandJSON(filename, cmake_dir):
    """
    Searches for the compile_commands.json generated by CMake and returns
    its directory as needed by ycm. It will only search a maximum of 5
    directories (including the direcotry of filename).
    filename is the path of a source file (.c, .h, ...).
    cmake_dir is the name of build directory to search for.
    """
    dirname = filename
    for i in range(0, 5):
        dirname, fn = os.path.split(dirname)
        comp_commands = os.path.join(dirname, cmake_dir, 'compile_commands.json')
        if os.path.exists(comp_commands):
            return os.path.join(dirname, cmake_dir)
        if not fn: # reached root dir
            return

def getFlagsForHeaderFile(header_file, database):
    """
    Tries to find the compile flags for the header file.
    First searches for the corresponding source file (foo.h -> foo.c,
    foo.hpp -> foo.cpp). If this fails searches for any source file in the same
    directory and uses its flags.
    """
    source_ext = '.c' if isCFile(header_file) else '.cpp'
    source_file = os.path.join(os.path.splitext(header_file)[1], source_ext)
    if os.path.exists(source_file):
        comp_info = database.GetCompilationInfoForFile(source_file)
        return list(comp_info.compiler_flags_)
    else:
        directory = os.path.split(header_file)[0]
        for f in os.listdir(directory):
            if f.endswith(source_ext):
                path = os.path.join(directory, f)
                comp_info = database.GetCompilationInfoForFile(path)
                return list(comp_info.compiler_flags_)
    raise Exception("Found no flags for this file")

def FlagsForFile(filename, **kwargs):
    flags = []
    comp_commands = discoverCompileCommandJSON(filename, 'build')
    if comp_commands:
        if not DATABASE:
            global DATABASE
            DATABASE = ycm_core.CompilationDatabase(comp_commands)

        if not DATABASE.DatabaseSuccessfullyLoaded:
            raise Exception("cmake database failed to load")

        if isHeaderFile(filename):
            flags += getFlagsForHeaderFile(filename, DATABASE)
        else:
            comp_info = DATABASE.GetCompilationInfoForFile(filename)
            flags += list(comp_info.compiler_flags_)

        flags += DEFAULT_FLAGS
    else:
        flags += DEFAULT_FLAGS
        if isCFile(filename):
            flags += ['-std=c99']
        elif isCPPFile(filename):
            flags += ['-std=c++11']

    if isCFile(filename):
        flags += ['-x', 'c']
        flags += C_INCLUDES
    elif isCPPFile(filename):
        flags += ['-x', 'c++']
        flags += CPP_INCLUDES

    return { 'flags': flags, 'do_cache': True }

