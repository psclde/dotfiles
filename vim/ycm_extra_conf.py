# This ycm_extra_conf.py tries to be as generic as possible.
#
# Should work for C (.c, .h) and C++ (.cpp, .hpp) files.
#
# First it searches in the source tree for the compile_commands.json
# generated by CMake. It assumes that a directory named 'build' is somewhere
# in the source tree (basically the CMake building directory)
# Because the compile_commands.json file does not contain any information
# about the header files the script tries to find the corresponding source file
# or, if that fails, any other source file in the same directory and uses the
# flags of that file.
#
# If no compile_commands.json file is found some default flags will be returned.
#
# It most definitly has bugs and edge cases and will be improved in the future.

import ycm_core
import os
import logging
from subprocess import Popen, PIPE

def getClangIncludePaths(lang):
    """
    Gets the default include paths from clang for the specified language.
    """
    p = Popen(["clang", "-v", "-E", "-x", lang, "-"], stdin=PIPE, stdout=PIPE,
            stderr=PIPE)
    output = p.communicate("\n")[1]

    flags = []
    foundFlags = False
    for line in output.splitlines():
        if line == "#include <...> search starts here:":
            foundFlags = True
            continue
        if line == "End of search list.":
            break

        if foundFlags and "(framework directory)" not in line:
            flags.append('-isystem')
            flags.append(line.strip())
    return flags


DEFAULT_FLAGS_COMMON = [
    '-Wall',
    '-Wextra',
    '-pedantic',
    '-DNDEBUG',
    '-isystem',
    '/usr/local/include',
]

DEFAULT_C_FLAGS = [
    '-std=c99',
    '-x', 'c',
]

DEFAULT_CPP_FLAGS = [
    '-std=c++14',
    '-x', 'c++'
]

DEFAULT_C_INCLUDES = getClangIncludePaths('c')
DEFAULT_CPP_INCLUDES = getClangIncludePaths('c++')

SOURCE_EXTENSIONS = [
    '.c',
    '.cpp',
]

def isHeaderFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.hpp']

def isCFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.c']

def isCPPFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.hpp', '.cpp']

def discoverCompileCommandJSON(filename, cmake_dir):
    """
    Searches for the compile_commands.json generated by CMake and returns
    its directory as needed by ycm. It will only search a maximum of 5
    directories (including the direcotry of filename).
    filename is the path of a source file (.c, .h, ...).
    cmake_dir is the name of build directory to search for.
    """
    dirname = filename
    for i in range(0, 5):
        dirname, fn = os.path.split(dirname)
        comp_commands = os.path.join(dirname, cmake_dir, 'compile_commands.json')
        if os.path.exists(comp_commands):
            return os.path.join(dirname, cmake_dir)
        if not fn: # reached root dir
            return

def getFlagsForHeaderFile(header_file, database):
    """
    Tries to find the compile flags for the header file.  First searches for the
    corresponding source file. if this fails searches for any source file in the
    same directory and uses its flags.
    """

    logging.info("Searching for source file corresponding to header file %s",
            header_file)
    for source_ext in SOURCE_EXTENSIONS:
        source_file = os.path.splitext(header_file)[0] + source_ext
        if os.path.exists(source_file):
            logging.info("Found source file in same directory: %s", source_file)
            comp_info = database.GetCompilationInfoForFile(source_file)
            return list(comp_info.compiler_flags_)


    logging.info("Did not find corresponding source file. Searching for any other source file in same directory.")
    directory = os.path.split(header_file)[0]
    for f in os.listdir(directory):
        for source_ext in SOURCE_EXTENSIONS:
            if f.endswith(source_ext):
                logging.info("Found alternative source file: %s", source_file)
                path = os.path.join(directory, f)
                comp_info = database.GetCompilationInfoForFile(path)
                return list(comp_info.compiler_flags_)

    # TODO fallback
    raise Exception("Could not find flags for " + header_file)

def FlagsForFile(filename, **kwargs):
    flags = []

    comp_commands = discoverCompileCommandJSON(filename, 'build')
    if comp_commands:
        database = ycm_core.CompilationDatabase(comp_commands)
        if not database.DatabaseSuccessfullyLoaded:
            raise Exception("cmake database failed to load")

        if isHeaderFile(filename):
            flags += getFlagsForHeaderFile(filename, database)
        else:
            comp_info = database.GetCompilationInfoForFile(filename)
            flags += list(comp_info.compiler_flags_)
    else:
        flags += DEFAULT_FLAGS_COMMON
        if isCFile(filename):
            flags += DEFAULT_C_FLAGS
            flags += DEFAULT_C_INCLUDES
        elif isCPPFile(filename):
            flags += DEFAULT_CPP_FLAGS
            flags += DEFAULT_CPP_INCLUDES

    return { 'flags': flags, 'do_cache': True }

